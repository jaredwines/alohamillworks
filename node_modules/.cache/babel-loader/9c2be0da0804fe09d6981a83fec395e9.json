{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport * as React from 'react';\nimport { useContext, useRef, useMemo, useEffect, useImperativeHandle, forwardRef } from 'react';\nimport * as PropTypes from 'prop-types';\nimport StaticMap, { getViewport } from './static-map';\nimport { MAPBOX_LIMITS } from '../utils/map-state';\nimport TransitionManager from '../utils/transition-manager';\nimport MapContext, { MapContextProvider } from './map-context';\nimport { EventManager } from 'mjolnir.js';\nimport MapController from '../utils/map-controller';\nimport useIsomorphicLayoutEffect from '../utils/use-isomorphic-layout-effect';\nvar propTypes = Object.assign({}, StaticMap.propTypes, {\n  maxZoom: PropTypes.number,\n  minZoom: PropTypes.number,\n  maxPitch: PropTypes.number,\n  minPitch: PropTypes.number,\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n  onInteractionStateChange: PropTypes.func,\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  transitionInterpolator: PropTypes.object,\n  transitionInterruption: PropTypes.number,\n  transitionEasing: PropTypes.func,\n  onTransitionStart: PropTypes.func,\n  onTransitionInterrupt: PropTypes.func,\n  onTransitionEnd: PropTypes.func,\n  scrollZoom: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  dragPan: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  dragRotate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  doubleClickZoom: PropTypes.bool,\n  touchZoom: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  touchRotate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  keyboard: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onDblClick: PropTypes.func,\n  onContextMenu: PropTypes.func,\n  onMouseDown: PropTypes.func,\n  onMouseMove: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  onTouchStart: PropTypes.func,\n  onTouchMove: PropTypes.func,\n  onTouchEnd: PropTypes.func,\n  onMouseEnter: PropTypes.func,\n  onMouseLeave: PropTypes.func,\n  onMouseOut: PropTypes.func,\n  onWheel: PropTypes.func,\n  touchAction: PropTypes.string,\n  eventRecognizerOptions: PropTypes.object,\n  clickRadius: PropTypes.number,\n  interactiveLayerIds: PropTypes.array,\n  getCursor: PropTypes.func,\n  controller: PropTypes.instanceOf(MapController)\n});\n\nvar getDefaultCursor = function getDefaultCursor(_ref) {\n  var isDragging = _ref.isDragging,\n      isHovering = _ref.isHovering;\n  return isDragging ? 'grabbing' : isHovering ? 'pointer' : 'grab';\n};\n\nvar defaultProps = Object.assign({}, StaticMap.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {\n  onViewStateChange: null,\n  onViewportChange: null,\n  onClick: null,\n  onNativeClick: null,\n  onHover: null,\n  onContextMenu: function onContextMenu(event) {\n    return event.preventDefault();\n  },\n  scrollZoom: true,\n  dragPan: true,\n  dragRotate: true,\n  doubleClickZoom: true,\n  touchZoom: true,\n  touchRotate: false,\n  keyboard: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  clickRadius: 0,\n  getCursor: getDefaultCursor\n});\n\nfunction normalizeEvent(event) {\n  if (event.lngLat || !event.offsetCenter) {\n    return event;\n  }\n\n  var _event$offsetCenter = event.offsetCenter,\n      x = _event$offsetCenter.x,\n      y = _event$offsetCenter.y;\n\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return event;\n  }\n\n  var pos = [x, y];\n  event.point = pos;\n  event.lngLat = this.viewport.unproject(pos);\n  return event;\n}\n\nfunction getFeatures(pos) {\n  var map = this.map;\n\n  if (!map || !pos) {\n    return null;\n  }\n\n  var queryParams = {};\n  var size = this.props.clickRadius;\n\n  if (this.props.interactiveLayerIds) {\n    queryParams.layers = this.props.interactiveLayerIds;\n  }\n\n  try {\n    return map.queryRenderedFeatures(size ? [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]] : pos, queryParams);\n  } catch (_unused) {\n    return null;\n  }\n}\n\nfunction onEvent(callbackName, event) {\n  var func = this.props[callbackName];\n\n  if (func) {\n    func(normalizeEvent.call(this, event));\n  }\n}\n\nfunction onPointerDown(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchStart' : 'onMouseDown', event);\n}\n\nfunction onPointerUp(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchEnd' : 'onMouseUp', event);\n}\n\nfunction onPointerMove(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchMove' : 'onMouseMove', event);\n\n  if (!this.state.isDragging) {\n    var _this$props = this.props,\n        onHover = _this$props.onHover,\n        interactiveLayerIds = _this$props.interactiveLayerIds;\n    var features;\n    event = normalizeEvent.call(this, event);\n\n    if (interactiveLayerIds || onHover) {\n      features = getFeatures.call(this, event.point);\n    }\n\n    var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);\n    var isEntering = isHovering && !this.state.isHovering;\n    var isExiting = !isHovering && this.state.isHovering;\n\n    if (onHover || isEntering) {\n      event.features = features;\n\n      if (onHover) {\n        onHover(event);\n      }\n    }\n\n    if (isEntering) {\n      onEvent.call(this, 'onMouseEnter', event);\n    }\n\n    if (isExiting) {\n      onEvent.call(this, 'onMouseLeave', event);\n    }\n\n    if (isEntering || isExiting) {\n      this.setState({\n        isHovering: isHovering\n      });\n    }\n  }\n}\n\nfunction onPointerClick(event) {\n  var _this$props2 = this.props,\n      onClick = _this$props2.onClick,\n      onNativeClick = _this$props2.onNativeClick,\n      onDblClick = _this$props2.onDblClick,\n      doubleClickZoom = _this$props2.doubleClickZoom;\n  var callbacks = [];\n  var isDoubleClickEnabled = onDblClick || doubleClickZoom;\n\n  switch (event.type) {\n    case 'anyclick':\n      callbacks.push(onNativeClick);\n\n      if (!isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n\n      break;\n\n    case 'click':\n      if (isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n\n      break;\n\n    default:\n  }\n\n  callbacks = callbacks.filter(Boolean);\n\n  if (callbacks.length) {\n    event = normalizeEvent.call(this, event);\n    event.features = getFeatures.call(this, event.point);\n    callbacks.forEach(function (cb) {\n      return cb(event);\n    });\n  }\n}\n\nfunction getRefHandles(staticMapRef) {\n  return {\n    getMap: staticMapRef.current && staticMapRef.current.getMap,\n    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures\n  };\n}\n\nvar InteractiveMap = forwardRef(function (props, ref) {\n  var parentContext = useContext(MapContext);\n  var controller = useMemo(function () {\n    return props.controller || new MapController();\n  }, []);\n  var eventManager = useMemo(function () {\n    return new EventManager(null, {\n      touchAction: props.touchAction,\n      recognizerOptions: props.eventRecognizerOptions\n    });\n  }, []);\n  var eventCanvasRef = useRef(null);\n  var staticMapRef = useRef(null);\n\n  var _thisRef = useRef({\n    width: 0,\n    height: 0,\n    state: {\n      isHovering: false,\n      isDragging: false\n    }\n  });\n\n  var thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();\n\n  thisRef.setState = function (newState) {\n    thisRef.state = _objectSpread(_objectSpread({}, thisRef.state), newState);\n    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);\n  };\n\n  var inRender = true;\n  var viewportUpdateRequested;\n  var stateUpdateRequested;\n\n  var handleViewportChange = function handleViewportChange(viewState, interactionState, oldViewState) {\n    if (inRender) {\n      viewportUpdateRequested = [viewState, interactionState, oldViewState];\n      return;\n    }\n\n    var _thisRef$props = thisRef.props,\n        onViewStateChange = _thisRef$props.onViewStateChange,\n        onViewportChange = _thisRef$props.onViewportChange;\n\n    if (onViewStateChange) {\n      onViewStateChange({\n        viewState: viewState,\n        interactionState: interactionState,\n        oldViewState: oldViewState\n      });\n    }\n\n    if (onViewportChange) {\n      onViewportChange(viewState, interactionState, oldViewState);\n    }\n  };\n\n  useImperativeHandle(ref, function () {\n    return getRefHandles(staticMapRef);\n  }, []);\n  var context = useMemo(function () {\n    return _objectSpread(_objectSpread({}, parentContext), {}, {\n      eventManager: eventManager,\n      container: parentContext.container || eventCanvasRef.current\n    });\n  }, [parentContext, eventCanvasRef.current]);\n  context.onViewportChange = handleViewportChange;\n  context.viewport = parentContext.viewport || getViewport(thisRef);\n  thisRef.viewport = context.viewport;\n\n  var handleInteractionStateChange = function handleInteractionStateChange(interactionState) {\n    var _interactionState$isD = interactionState.isDragging,\n        isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;\n\n    if (isDragging !== thisRef.state.isDragging) {\n      thisRef.setState({\n        isDragging: isDragging\n      });\n    }\n\n    if (inRender) {\n      stateUpdateRequested = interactionState;\n      return;\n    }\n\n    var onInteractionStateChange = thisRef.props.onInteractionStateChange;\n\n    if (onInteractionStateChange) {\n      onInteractionStateChange(interactionState);\n    }\n  };\n\n  var updateControllerOpts = function updateControllerOpts() {\n    if (thisRef.width && thisRef.height) {\n      controller.setOptions(_objectSpread(_objectSpread(_objectSpread({}, thisRef.props), thisRef.props.viewState), {}, {\n        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),\n        onViewportChange: handleViewportChange,\n        onStateChange: handleInteractionStateChange,\n        eventManager: eventManager,\n        width: thisRef.width,\n        height: thisRef.height\n      }));\n    }\n  };\n\n  var onResize = function onResize(_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    thisRef.width = width;\n    thisRef.height = height;\n    updateControllerOpts();\n    thisRef.props.onResize({\n      width: width,\n      height: height\n    });\n  };\n\n  useEffect(function () {\n    eventManager.setElement(eventCanvasRef.current);\n    eventManager.on({\n      pointerdown: onPointerDown.bind(thisRef),\n      pointermove: onPointerMove.bind(thisRef),\n      pointerup: onPointerUp.bind(thisRef),\n      pointerleave: onEvent.bind(thisRef, 'onMouseOut'),\n      click: onPointerClick.bind(thisRef),\n      anyclick: onPointerClick.bind(thisRef),\n      dblclick: onEvent.bind(thisRef, 'onDblClick'),\n      wheel: onEvent.bind(thisRef, 'onWheel'),\n      contextmenu: onEvent.bind(thisRef, 'onContextMenu')\n    });\n    return function () {\n      eventManager.destroy();\n    };\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    if (viewportUpdateRequested) {\n      handleViewportChange.apply(void 0, _toConsumableArray(viewportUpdateRequested));\n    }\n\n    if (stateUpdateRequested) {\n      handleInteractionStateChange(stateUpdateRequested);\n    }\n  });\n  updateControllerOpts();\n  var width = props.width,\n      height = props.height,\n      style = props.style,\n      getCursor = props.getCursor;\n  var eventCanvasStyle = useMemo(function () {\n    return _objectSpread(_objectSpread({\n      position: 'relative'\n    }, style), {}, {\n      width: width,\n      height: height,\n      cursor: getCursor(thisRef.state)\n    });\n  }, [style, width, height, getCursor, thisRef.state]);\n\n  if (!viewportUpdateRequested || !thisRef._child) {\n    thisRef._child = React.createElement(MapContextProvider, {\n      value: context\n    }, React.createElement(\"div\", {\n      key: \"event-canvas\",\n      ref: eventCanvasRef,\n      style: eventCanvasStyle\n    }, React.createElement(StaticMap, _extends({}, props, {\n      width: \"100%\",\n      height: \"100%\",\n      style: null,\n      onResize: onResize,\n      ref: staticMapRef\n    }))));\n  }\n\n  inRender = false;\n  return thisRef._child;\n});\nInteractiveMap.supported = StaticMap.supported;\nInteractiveMap.propTypes = propTypes;\nInteractiveMap.defaultProps = defaultProps;\nexport default InteractiveMap;","map":{"version":3,"mappings":"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","names":["React","useContext","useRef","useMemo","useEffect","useImperativeHandle","forwardRef","PropTypes","StaticMap","getViewport","MAPBOX_LIMITS","TransitionManager","MapContext","MapContextProvider","EventManager","MapController","useIsomorphicLayoutEffect","propTypes","Object","assign","maxZoom","number","minZoom","maxPitch","minPitch","onViewStateChange","func","onViewportChange","onInteractionStateChange","transitionDuration","oneOfType","string","transitionInterpolator","object","transitionInterruption","transitionEasing","onTransitionStart","onTransitionInterrupt","onTransitionEnd","scrollZoom","bool","dragPan","dragRotate","doubleClickZoom","touchZoom","touchRotate","keyboard","onHover","onClick","onDblClick","onContextMenu","onMouseDown","onMouseMove","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","onMouseEnter","onMouseLeave","onMouseOut","onWheel","touchAction","eventRecognizerOptions","clickRadius","interactiveLayerIds","array","getCursor","controller","instanceOf","getDefaultCursor","isDragging","isHovering","defaultProps","onNativeClick","event","preventDefault","normalizeEvent","lngLat","offsetCenter","x","y","Number","isFinite","pos","point","viewport","unproject","getFeatures","map","queryParams","size","props","layers","queryRenderedFeatures","onEvent","callbackName","call","onPointerDown","pointerType","onPointerUp","onPointerMove","state","features","Boolean","length","isEntering","isExiting","setState","onPointerClick","callbacks","isDoubleClickEnabled","type","push","filter","forEach","cb","getRefHandles","staticMapRef","getMap","current","InteractiveMap","ref","parentContext","eventManager","recognizerOptions","eventCanvasRef","_thisRef","width","height","thisRef","newState","style","cursor","inRender","viewportUpdateRequested","stateUpdateRequested","handleViewportChange","viewState","interactionState","oldViewState","context","container","handleInteractionStateChange","updateControllerOpts","setOptions","isInteractive","onStateChange","onResize","setElement","on","pointerdown","bind","pointermove","pointerup","pointerleave","click","anyclick","dblclick","wheel","contextmenu","destroy","eventCanvasStyle","position","_child","value","key","supported"],"sources":["../../../src/components/interactive-map.js"],"sourcesContent":["import * as React from 'react';\nimport {useContext, useRef, useMemo, useEffect, useImperativeHandle, forwardRef} from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport StaticMap, {getViewport} from './static-map';\nimport {MAPBOX_LIMITS} from '../utils/map-state';\n\nimport TransitionManager from '../utils/transition-manager';\nimport MapContext, {MapContextProvider} from './map-context';\n\nimport {EventManager} from 'mjolnir.js';\nimport MapController from '../utils/map-controller';\nimport useIsomorphicLayoutEffect from '../utils/use-isomorphic-layout-effect';\n\nconst propTypes = Object.assign({}, StaticMap.propTypes, {\n  // Additional props on top of StaticMap\n\n  /** Viewport constraints */\n  // Max zoom level\n  maxZoom: PropTypes.number,\n  // Min zoom level\n  minZoom: PropTypes.number,\n  // Max pitch in degrees\n  maxPitch: PropTypes.number,\n  // Min pitch in degrees\n  minPitch: PropTypes.number,\n\n  // Callbacks fired when the user interacted with the map. The object passed to the callbacks\n  // contains viewport properties such as `longitude`, `latitude`, `zoom` etc.\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n  onInteractionStateChange: PropTypes.func,\n\n  /** Viewport transition **/\n  // transition duration for viewport change\n  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  // TransitionInterpolator instance, can be used to perform custom transitions.\n  transitionInterpolator: PropTypes.object,\n  // type of interruption of current transition on update.\n  transitionInterruption: PropTypes.number,\n  // easing function\n  transitionEasing: PropTypes.func,\n  // transition status update functions\n  onTransitionStart: PropTypes.func,\n  onTransitionInterrupt: PropTypes.func,\n  onTransitionEnd: PropTypes.func,\n\n  /** Enables control event handling */\n  // Scroll to zoom\n  scrollZoom: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  // Drag to pan\n  dragPan: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  // Drag to rotate\n  dragRotate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  // Double click to zoom\n  doubleClickZoom: PropTypes.bool,\n  // Multitouch zoom\n  touchZoom: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  // Multitouch rotate\n  touchRotate: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  // Keyboard\n  keyboard: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n\n  /** Event callbacks */\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onDblClick: PropTypes.func,\n  onContextMenu: PropTypes.func,\n  onMouseDown: PropTypes.func,\n  onMouseMove: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  onTouchStart: PropTypes.func,\n  onTouchMove: PropTypes.func,\n  onTouchEnd: PropTypes.func,\n  onMouseEnter: PropTypes.func,\n  onMouseLeave: PropTypes.func,\n  onMouseOut: PropTypes.func,\n  onWheel: PropTypes.func,\n\n  /** Custom touch-action CSS for the event canvas. Defaults to 'none' */\n  touchAction: PropTypes.string,\n\n  /** Custom hammer.js recognizer options */\n  eventRecognizerOptions: PropTypes.object,\n\n  /** Radius to detect features around a clicked point. Defaults to 0. */\n  clickRadius: PropTypes.number,\n\n  /** List of layers that are interactive */\n  interactiveLayerIds: PropTypes.array,\n\n  /** Accessor that returns a cursor style to show interactive state */\n  getCursor: PropTypes.func,\n\n  // A map control instance to replace the default map controller\n  // The object must expose a method: `setOptions(opts)`\n  controller: PropTypes.instanceOf(MapController)\n});\n\nconst getDefaultCursor = ({isDragging, isHovering}) =>\n  isDragging ? 'grabbing' : isHovering ? 'pointer' : 'grab';\n\nconst defaultProps = Object.assign(\n  {},\n  StaticMap.defaultProps,\n  MAPBOX_LIMITS,\n  TransitionManager.defaultProps,\n  {\n    onViewStateChange: null,\n    onViewportChange: null,\n    onClick: null,\n    onNativeClick: null,\n    onHover: null,\n    onContextMenu: event => event.preventDefault(),\n\n    scrollZoom: true,\n    dragPan: true,\n    dragRotate: true,\n    doubleClickZoom: true,\n    touchZoom: true,\n    touchRotate: false,\n    keyboard: true,\n\n    touchAction: 'none',\n    eventRecognizerOptions: {},\n    clickRadius: 0,\n    getCursor: getDefaultCursor\n  }\n);\n\n/* Event handlers */\nfunction normalizeEvent(event) {\n  if (event.lngLat || !event.offsetCenter) {\n    return event;\n  }\n\n  const {\n    offsetCenter: {x, y}\n  } = event;\n  // https://github.com/visgl/react-map-gl/issues/1449\n  // TODO - fix in mjolnir.js\n  if (!Number.isFinite(x) || !Number.isFinite(y)) {\n    return event;\n  }\n  const pos = [x, y];\n\n  event.point = pos;\n\n  event.lngLat = this.viewport.unproject(pos);\n\n  return event;\n}\n\nfunction getFeatures(pos) {\n  const {map} = this;\n\n  if (!map || !pos) {\n    return null;\n  }\n\n  const queryParams = {};\n  const size = this.props.clickRadius;\n\n  if (this.props.interactiveLayerIds) {\n    queryParams.layers = this.props.interactiveLayerIds;\n  }\n\n  try {\n    // This may fail if map is still loading\n    return map.queryRenderedFeatures(\n      size\n        ? // Radius enables point features, like marker symbols, to be clicked.\n          [\n            [pos[0] - size, pos[1] + size],\n            [pos[0] + size, pos[1] - size]\n          ]\n        : pos,\n      queryParams\n    );\n  } catch {\n    return null;\n  }\n}\n\nfunction onEvent(callbackName, event) {\n  const func = this.props[callbackName];\n  if (func) {\n    func(normalizeEvent.call(this, event));\n  }\n}\n\nfunction onPointerDown(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchStart' : 'onMouseDown', event);\n}\n\nfunction onPointerUp(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchEnd' : 'onMouseUp', event);\n}\n\n// eslint-disable-next-line complexity\nfunction onPointerMove(event) {\n  onEvent.call(this, event.pointerType === 'touch' ? 'onTouchMove' : 'onMouseMove', event);\n\n  if (!this.state.isDragging) {\n    const {onHover, interactiveLayerIds} = this.props;\n    let features;\n    event = normalizeEvent.call(this, event);\n    if (interactiveLayerIds || onHover) {\n      features = getFeatures.call(this, event.point);\n    }\n\n    const isHovering = Boolean(interactiveLayerIds && features && features.length > 0);\n    const isEntering = isHovering && !this.state.isHovering;\n    const isExiting = !isHovering && this.state.isHovering;\n\n    if (onHover || isEntering) {\n      event.features = features;\n\n      // backward compatibility: v3 `onHover` interface\n      if (onHover) {\n        onHover(event);\n      }\n    }\n\n    if (isEntering) {\n      onEvent.call(this, 'onMouseEnter', event);\n    }\n    if (isExiting) {\n      onEvent.call(this, 'onMouseLeave', event);\n    }\n    if (isEntering || isExiting) {\n      this.setState({isHovering});\n    }\n  }\n}\n\nfunction onPointerClick(event) {\n  const {onClick, onNativeClick, onDblClick, doubleClickZoom} = this.props;\n  let callbacks = [];\n  const isDoubleClickEnabled = onDblClick || doubleClickZoom;\n\n  // `click` is only fired on single click. `anyclick` is fired twice if double clicking.\n  // `click` has a delay period after pointer up that prevents it from firing when\n  // double clicking. `anyclick` is always fired immediately after pointer up.\n  // If double click is turned off by the user, we want to immediately fire the\n  // onClick event. Otherwise, we wait to make sure it's a single click.\n  switch (event.type) {\n    case 'anyclick':\n      callbacks.push(onNativeClick);\n      if (!isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n      break;\n\n    case 'click':\n      if (isDoubleClickEnabled) {\n        callbacks.push(onClick);\n      }\n      break;\n\n    default:\n  }\n\n  callbacks = callbacks.filter(Boolean);\n\n  if (callbacks.length) {\n    event = normalizeEvent.call(this, event);\n    // backward compatibility: v3 `onClick` interface\n    event.features = getFeatures.call(this, event.point);\n    callbacks.forEach(cb => cb(event));\n  }\n}\n/* End of event handers */\n\nfunction getRefHandles(staticMapRef) {\n  return {\n    getMap: staticMapRef.current && staticMapRef.current.getMap,\n    queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures\n  };\n}\n\n/* eslint-disable max-statements */\nconst InteractiveMap = forwardRef((props, ref) => {\n  const parentContext = useContext(MapContext);\n  const controller = useMemo(() => props.controller || new MapController(), []);\n  const eventManager = useMemo(\n    () =>\n      new EventManager(null, {\n        touchAction: props.touchAction,\n        recognizerOptions: props.eventRecognizerOptions\n      }),\n    []\n  );\n  const eventCanvasRef = useRef(null);\n  const staticMapRef = useRef(null);\n\n  // Event handlers are registered once but need access to the latest props\n  // This is an anti-pattern, though it maintains a persistent reference to the latest props/state of this component\n  const _thisRef = useRef({\n    width: 0,\n    height: 0,\n    state: {\n      isHovering: false,\n      isDragging: false\n    }\n  });\n  const thisRef = _thisRef.current;\n  thisRef.props = props;\n  thisRef.map = staticMapRef.current && staticMapRef.current.getMap();\n  thisRef.setState = newState => {\n    thisRef.state = {...thisRef.state, ...newState};\n    eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);\n  };\n\n  let inRender = true;\n  let viewportUpdateRequested;\n  let stateUpdateRequested;\n\n  const handleViewportChange = (viewState, interactionState, oldViewState) => {\n    if (inRender) {\n      // Do not call the callbacks during render - may result in \"cannot update during an existing state transition\" error.\n      // Defer the update until after render\n      viewportUpdateRequested = [viewState, interactionState, oldViewState];\n      return;\n    }\n    const {onViewStateChange, onViewportChange} = thisRef.props;\n\n    if (onViewStateChange) {\n      onViewStateChange({viewState, interactionState, oldViewState});\n    }\n    if (onViewportChange) {\n      onViewportChange(viewState, interactionState, oldViewState);\n    }\n  };\n\n  useImperativeHandle(ref, () => getRefHandles(staticMapRef), []);\n\n  const context = useMemo(\n    () => ({\n      ...parentContext,\n      eventManager,\n      container: parentContext.container || eventCanvasRef.current\n    }),\n    [parentContext, eventCanvasRef.current]\n  );\n  context.onViewportChange = handleViewportChange;\n  context.viewport = parentContext.viewport || getViewport(thisRef);\n  thisRef.viewport = context.viewport;\n\n  const handleInteractionStateChange = interactionState => {\n    const {isDragging = false} = interactionState;\n    if (isDragging !== thisRef.state.isDragging) {\n      thisRef.setState({isDragging});\n    }\n\n    if (inRender) {\n      // Do not call the callbacks during render - may result in \"cannot update during an existing state transition\" error.\n      // Defer the update until after render\n      stateUpdateRequested = interactionState;\n      return;\n    }\n\n    const {onInteractionStateChange} = thisRef.props;\n    if (onInteractionStateChange) {\n      onInteractionStateChange(interactionState);\n    }\n  };\n\n  const updateControllerOpts = () => {\n    if (thisRef.width && thisRef.height) {\n      controller.setOptions({\n        ...thisRef.props,\n        ...thisRef.props.viewState,\n        isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),\n        onViewportChange: handleViewportChange,\n        onStateChange: handleInteractionStateChange,\n        eventManager,\n        width: thisRef.width,\n        height: thisRef.height\n      });\n    }\n  };\n\n  const onResize = ({width, height}) => {\n    thisRef.width = width;\n    thisRef.height = height;\n    updateControllerOpts();\n    thisRef.props.onResize({width, height});\n  };\n\n  useEffect(() => {\n    eventManager.setElement(eventCanvasRef.current);\n    // Register event handlers\n    eventManager.on({\n      pointerdown: onPointerDown.bind(thisRef),\n      pointermove: onPointerMove.bind(thisRef),\n      pointerup: onPointerUp.bind(thisRef),\n      pointerleave: onEvent.bind(thisRef, 'onMouseOut'),\n      click: onPointerClick.bind(thisRef),\n      anyclick: onPointerClick.bind(thisRef),\n      dblclick: onEvent.bind(thisRef, 'onDblClick'),\n      wheel: onEvent.bind(thisRef, 'onWheel'),\n      contextmenu: onEvent.bind(thisRef, 'onContextMenu')\n    });\n\n    // Clean up on unmount\n    return () => {\n      eventManager.destroy();\n    };\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    if (viewportUpdateRequested) {\n      // Perform deferred updates\n      handleViewportChange(...viewportUpdateRequested);\n    }\n    if (stateUpdateRequested) {\n      handleInteractionStateChange(stateUpdateRequested);\n    }\n  });\n\n  updateControllerOpts();\n\n  const {width, height, style, getCursor} = props;\n\n  const eventCanvasStyle = useMemo(\n    () => ({\n      position: 'relative',\n      ...style,\n      width,\n      height,\n      cursor: getCursor(thisRef.state)\n    }),\n    [style, width, height, getCursor, thisRef.state]\n  );\n\n  if (!viewportUpdateRequested || !thisRef._child) {\n    // Only rerender if no viewport update has been requested during render.\n    // Otherwise return the last rendered child, and invoke the callback when we're done.\n    thisRef._child = (\n      <MapContextProvider value={context}>\n        <div key=\"event-canvas\" ref={eventCanvasRef} style={eventCanvasStyle}>\n          <StaticMap\n            {...props}\n            width=\"100%\"\n            height=\"100%\"\n            style={null}\n            onResize={onResize}\n            ref={staticMapRef}\n          />\n        </div>\n      </MapContextProvider>\n    );\n  }\n\n  inRender = false;\n  return thisRef._child;\n});\n\nInteractiveMap.supported = StaticMap.supported;\nInteractiveMap.propTypes = propTypes;\nInteractiveMap.defaultProps = defaultProps;\n\nexport default InteractiveMap;\n"]},"metadata":{},"sourceType":"module"}